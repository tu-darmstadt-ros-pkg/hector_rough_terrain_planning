"""autogenerated by genpy from flor_footstep_planner_msgs/FootstepPlannerParams.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import geometry_msgs.msg
import std_msgs.msg

class FootstepPlannerParams(genpy.Message):
  _md5sum = "9ad8f7c4522131fd5b4be7e580e2fb6f"
  _type = "flor_footstep_planner_msgs/FootstepPlannerParams"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """uint32 change_mask
# values for change mask
uint32 STEP_COST_ESTIMATOR   =   1
uint32 FOOTSTEP_SET          =   2
uint32 LOAD_MAP_STEP_COST    =   4
uint32 LOAD_GPR_STEP_COST    =   8
uint32 COLLISION_CHECK_TYPE  =  16
uint32 FOOT_SIZE             =  32
uint32 UPPER_BODY_SIZE       =  64
uint32 STANDARD_STEP_PARAMS  = 128
uint32 TERRAIN_MODEL         = 256

### STEP_COST_ESTIMATOR ########
# switch between EUCLIDEAN or GPR
uint8 step_cost_type
# values for step_cost_type
uint8 EUCLIDEAN_STEP_COST_ESTIMATOR = 0  # discrete footstep planning
uint8 GPR_STEP_COST_ESTIMATOR       = 1  # continous GPR-based planning
uint8 MAP_STEP_COST_ESTIMATOR       = 2  # continous map-based planning
uint8 BOUNDARY_STEP_COST_ESTIMATOR  = 3  # continous boundary-based planning
uint8 DYNAMICS_STEP_COST_ESTIMATOR  = 4  # continous boundary-based planning with dynamic restrictions

### FOOTSTEP_SET ########
# parameters for discret footstep planning mode
#flor_atlas_msgs/AtlasBehaviorStepData[] footstep_set            # set of footsteps (displacement vectors (in meter / rad))
float32[] footstep_cost                                         # cost for each footstep given in footstep set

### LOAD_GPR_STEP_COST ########
# map step cost file
std_msgs/String map_step_cost_file

### LOAD_MAP_STEP_COST ########
# destination of gpr file
std_msgs/String gpr_step_cost_file

### COLLISION_CHECK_TYPE ########
# collision check
uint8 collision_check_type

# values for collision_check_type (may composed via bitwise selection, e.g. foot and upper body => 3)
uint8 FEET_COLLISION        = 1
uint8 UPPER_BODY_COLLISION  = 2
uint8 FOOT_CONTACT_SUPPORT  = 4

### FOOT_SIZE ########
# setting foot size and/or upper body
geometry_msgs/Vector3 foot_size
geometry_msgs/Vector3 foot_origin_shift
float32 foot_seperation

### UPPER_BODY_SIZE ########
geometry_msgs/Vector3 upper_body_size
geometry_msgs/Vector3 upper_body_origin_shift

### TERRAIN_MODEL ########
bool use_terrain_model
uint32 min_sampling_steps_x
uint32 min_sampling_steps_y
uint32 max_sampling_steps_x
uint32 max_sampling_steps_y
float32  max_intrusion_z    
float32 max_ground_clearance 
float32 minimal_support    

### STANDARD_STEP_PARAMS ########
# standard params for steps
float32 step_duration
float32 sway_duration   # Ignored if it is less than 0.2
float32 swing_height    # Ignored if it is less than 0.1
float32 lift_height     # Ignored if it is less than 0.1

================================================================================
MSG: std_msgs/String
string data

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 

float64 x
float64 y
float64 z
"""
  # Pseudo-constants
  STEP_COST_ESTIMATOR = 1
  FOOTSTEP_SET = 2
  LOAD_MAP_STEP_COST = 4
  LOAD_GPR_STEP_COST = 8
  COLLISION_CHECK_TYPE = 16
  FOOT_SIZE = 32
  UPPER_BODY_SIZE = 64
  STANDARD_STEP_PARAMS = 128
  TERRAIN_MODEL = 256
  EUCLIDEAN_STEP_COST_ESTIMATOR = 0
  GPR_STEP_COST_ESTIMATOR = 1
  MAP_STEP_COST_ESTIMATOR = 2
  BOUNDARY_STEP_COST_ESTIMATOR = 3
  DYNAMICS_STEP_COST_ESTIMATOR = 4
  FEET_COLLISION = 1
  UPPER_BODY_COLLISION = 2
  FOOT_CONTACT_SUPPORT = 4

  __slots__ = ['change_mask','step_cost_type','footstep_cost','map_step_cost_file','gpr_step_cost_file','collision_check_type','foot_size','foot_origin_shift','foot_seperation','upper_body_size','upper_body_origin_shift','use_terrain_model','min_sampling_steps_x','min_sampling_steps_y','max_sampling_steps_x','max_sampling_steps_y','max_intrusion_z','max_ground_clearance','minimal_support','step_duration','sway_duration','swing_height','lift_height']
  _slot_types = ['uint32','uint8','float32[]','std_msgs/String','std_msgs/String','uint8','geometry_msgs/Vector3','geometry_msgs/Vector3','float32','geometry_msgs/Vector3','geometry_msgs/Vector3','bool','uint32','uint32','uint32','uint32','float32','float32','float32','float32','float32','float32','float32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       change_mask,step_cost_type,footstep_cost,map_step_cost_file,gpr_step_cost_file,collision_check_type,foot_size,foot_origin_shift,foot_seperation,upper_body_size,upper_body_origin_shift,use_terrain_model,min_sampling_steps_x,min_sampling_steps_y,max_sampling_steps_x,max_sampling_steps_y,max_intrusion_z,max_ground_clearance,minimal_support,step_duration,sway_duration,swing_height,lift_height

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(FootstepPlannerParams, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.change_mask is None:
        self.change_mask = 0
      if self.step_cost_type is None:
        self.step_cost_type = 0
      if self.footstep_cost is None:
        self.footstep_cost = []
      if self.map_step_cost_file is None:
        self.map_step_cost_file = std_msgs.msg.String()
      if self.gpr_step_cost_file is None:
        self.gpr_step_cost_file = std_msgs.msg.String()
      if self.collision_check_type is None:
        self.collision_check_type = 0
      if self.foot_size is None:
        self.foot_size = geometry_msgs.msg.Vector3()
      if self.foot_origin_shift is None:
        self.foot_origin_shift = geometry_msgs.msg.Vector3()
      if self.foot_seperation is None:
        self.foot_seperation = 0.
      if self.upper_body_size is None:
        self.upper_body_size = geometry_msgs.msg.Vector3()
      if self.upper_body_origin_shift is None:
        self.upper_body_origin_shift = geometry_msgs.msg.Vector3()
      if self.use_terrain_model is None:
        self.use_terrain_model = False
      if self.min_sampling_steps_x is None:
        self.min_sampling_steps_x = 0
      if self.min_sampling_steps_y is None:
        self.min_sampling_steps_y = 0
      if self.max_sampling_steps_x is None:
        self.max_sampling_steps_x = 0
      if self.max_sampling_steps_y is None:
        self.max_sampling_steps_y = 0
      if self.max_intrusion_z is None:
        self.max_intrusion_z = 0.
      if self.max_ground_clearance is None:
        self.max_ground_clearance = 0.
      if self.minimal_support is None:
        self.minimal_support = 0.
      if self.step_duration is None:
        self.step_duration = 0.
      if self.sway_duration is None:
        self.sway_duration = 0.
      if self.swing_height is None:
        self.swing_height = 0.
      if self.lift_height is None:
        self.lift_height = 0.
    else:
      self.change_mask = 0
      self.step_cost_type = 0
      self.footstep_cost = []
      self.map_step_cost_file = std_msgs.msg.String()
      self.gpr_step_cost_file = std_msgs.msg.String()
      self.collision_check_type = 0
      self.foot_size = geometry_msgs.msg.Vector3()
      self.foot_origin_shift = geometry_msgs.msg.Vector3()
      self.foot_seperation = 0.
      self.upper_body_size = geometry_msgs.msg.Vector3()
      self.upper_body_origin_shift = geometry_msgs.msg.Vector3()
      self.use_terrain_model = False
      self.min_sampling_steps_x = 0
      self.min_sampling_steps_y = 0
      self.max_sampling_steps_x = 0
      self.max_sampling_steps_y = 0
      self.max_intrusion_z = 0.
      self.max_ground_clearance = 0.
      self.minimal_support = 0.
      self.step_duration = 0.
      self.sway_duration = 0.
      self.swing_height = 0.
      self.lift_height = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_IB.pack(_x.change_mask, _x.step_cost_type))
      length = len(self.footstep_cost)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.pack(pattern, *self.footstep_cost))
      _x = self.map_step_cost_file.data
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gpr_step_cost_file.data
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_B6df6dB4I7f.pack(_x.collision_check_type, _x.foot_size.x, _x.foot_size.y, _x.foot_size.z, _x.foot_origin_shift.x, _x.foot_origin_shift.y, _x.foot_origin_shift.z, _x.foot_seperation, _x.upper_body_size.x, _x.upper_body_size.y, _x.upper_body_size.z, _x.upper_body_origin_shift.x, _x.upper_body_origin_shift.y, _x.upper_body_origin_shift.z, _x.use_terrain_model, _x.min_sampling_steps_x, _x.min_sampling_steps_y, _x.max_sampling_steps_x, _x.max_sampling_steps_y, _x.max_intrusion_z, _x.max_ground_clearance, _x.minimal_support, _x.step_duration, _x.sway_duration, _x.swing_height, _x.lift_height))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.map_step_cost_file is None:
        self.map_step_cost_file = std_msgs.msg.String()
      if self.gpr_step_cost_file is None:
        self.gpr_step_cost_file = std_msgs.msg.String()
      if self.foot_size is None:
        self.foot_size = geometry_msgs.msg.Vector3()
      if self.foot_origin_shift is None:
        self.foot_origin_shift = geometry_msgs.msg.Vector3()
      if self.upper_body_size is None:
        self.upper_body_size = geometry_msgs.msg.Vector3()
      if self.upper_body_origin_shift is None:
        self.upper_body_origin_shift = geometry_msgs.msg.Vector3()
      end = 0
      _x = self
      start = end
      end += 5
      (_x.change_mask, _x.step_cost_type,) = _struct_IB.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.footstep_cost = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.map_step_cost_file.data = str[start:end].decode('utf-8')
      else:
        self.map_step_cost_file.data = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gpr_step_cost_file.data = str[start:end].decode('utf-8')
      else:
        self.gpr_step_cost_file.data = str[start:end]
      _x = self
      start = end
      end += 146
      (_x.collision_check_type, _x.foot_size.x, _x.foot_size.y, _x.foot_size.z, _x.foot_origin_shift.x, _x.foot_origin_shift.y, _x.foot_origin_shift.z, _x.foot_seperation, _x.upper_body_size.x, _x.upper_body_size.y, _x.upper_body_size.z, _x.upper_body_origin_shift.x, _x.upper_body_origin_shift.y, _x.upper_body_origin_shift.z, _x.use_terrain_model, _x.min_sampling_steps_x, _x.min_sampling_steps_y, _x.max_sampling_steps_x, _x.max_sampling_steps_y, _x.max_intrusion_z, _x.max_ground_clearance, _x.minimal_support, _x.step_duration, _x.sway_duration, _x.swing_height, _x.lift_height,) = _struct_B6df6dB4I7f.unpack(str[start:end])
      self.use_terrain_model = bool(self.use_terrain_model)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_IB.pack(_x.change_mask, _x.step_cost_type))
      length = len(self.footstep_cost)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.footstep_cost.tostring())
      _x = self.map_step_cost_file.data
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gpr_step_cost_file.data
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      if python3:
        buff.write(struct.pack('<I%sB'%length, length, *_x))
      else:
        buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_B6df6dB4I7f.pack(_x.collision_check_type, _x.foot_size.x, _x.foot_size.y, _x.foot_size.z, _x.foot_origin_shift.x, _x.foot_origin_shift.y, _x.foot_origin_shift.z, _x.foot_seperation, _x.upper_body_size.x, _x.upper_body_size.y, _x.upper_body_size.z, _x.upper_body_origin_shift.x, _x.upper_body_origin_shift.y, _x.upper_body_origin_shift.z, _x.use_terrain_model, _x.min_sampling_steps_x, _x.min_sampling_steps_y, _x.max_sampling_steps_x, _x.max_sampling_steps_y, _x.max_intrusion_z, _x.max_ground_clearance, _x.minimal_support, _x.step_duration, _x.sway_duration, _x.swing_height, _x.lift_height))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.map_step_cost_file is None:
        self.map_step_cost_file = std_msgs.msg.String()
      if self.gpr_step_cost_file is None:
        self.gpr_step_cost_file = std_msgs.msg.String()
      if self.foot_size is None:
        self.foot_size = geometry_msgs.msg.Vector3()
      if self.foot_origin_shift is None:
        self.foot_origin_shift = geometry_msgs.msg.Vector3()
      if self.upper_body_size is None:
        self.upper_body_size = geometry_msgs.msg.Vector3()
      if self.upper_body_origin_shift is None:
        self.upper_body_origin_shift = geometry_msgs.msg.Vector3()
      end = 0
      _x = self
      start = end
      end += 5
      (_x.change_mask, _x.step_cost_type,) = _struct_IB.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.footstep_cost = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.map_step_cost_file.data = str[start:end].decode('utf-8')
      else:
        self.map_step_cost_file.data = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gpr_step_cost_file.data = str[start:end].decode('utf-8')
      else:
        self.gpr_step_cost_file.data = str[start:end]
      _x = self
      start = end
      end += 146
      (_x.collision_check_type, _x.foot_size.x, _x.foot_size.y, _x.foot_size.z, _x.foot_origin_shift.x, _x.foot_origin_shift.y, _x.foot_origin_shift.z, _x.foot_seperation, _x.upper_body_size.x, _x.upper_body_size.y, _x.upper_body_size.z, _x.upper_body_origin_shift.x, _x.upper_body_origin_shift.y, _x.upper_body_origin_shift.z, _x.use_terrain_model, _x.min_sampling_steps_x, _x.min_sampling_steps_y, _x.max_sampling_steps_x, _x.max_sampling_steps_y, _x.max_intrusion_z, _x.max_ground_clearance, _x.minimal_support, _x.step_duration, _x.sway_duration, _x.swing_height, _x.lift_height,) = _struct_B6df6dB4I7f.unpack(str[start:end])
      self.use_terrain_model = bool(self.use_terrain_model)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_IB = struct.Struct("<IB")
_struct_B6df6dB4I7f = struct.Struct("<B6df6dB4I7f")
